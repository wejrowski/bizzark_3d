package com.bizzark{		import flash.display.Stage;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.display.Sprite;	import flash.utils.Dictionary;	import flash.events.Event;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import fl.transitions.easing.*;	import fl.transitions.*;	import flash.display.LineScaleMode;    import flash.display.CapsStyle;    import flash.display.JointStyle;	import flash.display.GradientType;		// Import the FIVe3D classes needed.	import five3D.display.DynamicText3D;	import five3D.display.Scene3D;	//import five3D.display.Shape3D;	import five3D.display.Sprite3D;	import five3D.typography.FuturaCondensedBold;	import five3D.utils.Drawing;		public class Scene3d extends Sprite {		private var __scene:Scene3D;				private var __trianglesDictionary:Dictionary = new Dictionary();		private var __triangles:uint = 0;				private var __container:Sprite3D;		private var world:DynamicText3D = new DynamicText3D(FuturaCondensedBold);// 1st child of __container		private var Tz:Tween;		private var Tx:Tween;		private var Ty:Tween;			private var Try:Tween;		private var Trx:Tween;		private var Ta:Tween;				public function Scene3d(){			addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		}		private function addedToStageHandler(event:Event):void { // HANDLER			createScene();// adds __scene which is a Scene3d			createBizzark();			createShapes();// cube is Scene3d adds to __scene.. creates Sprite3d faces.			stage.addEventListener(Event.RESIZE, resizeEvent);			resizeEvent('');			initializeMovement();		}				private function createBizzark():void{			__container = new Sprite3D();			__container.rotationX = 0;			__container.rotationY = 0;			__container.x=y=0;			__container.mouseChildren = false;			__scene.addChild(__container);			__container.childrenSorted = true;			world.size = 100;			world.color = 0xF9B30F;			world.text = "BIZZARK";			world.x = -225;			world.y = -this.height/2-50;			__container.addChild(world);		}		function resizeEvent(e){			this.x = (stage.stageWidth/2)-100/2;			this.y = (stage.stageHeight/2)-63/2;					}				private function createScene():void {			__scene = new Scene3D();			__scene.ambientLightIntensity = 0;			addChild(__scene);		}		var double:int = 1800;		var half:int = double/2;						private function createShapes():void {			//CREATE 60 TRIANGLES			for(var ts:uint = 0; ts<60; ts++){				createShape(Math.random()*double-half, Math.random()*double-half, Math.random()*double-half, Math.random()*359-180, Math.random()*359-180, Math.random()*359-180);			}		}		private function createShape(x:Number, y:Number, z:Number, rotationx:Number, rotationy:Number, rotationz:Number):void {			var triangleContainer:Sprite3D = new Sprite3D();			var face:Sprite3D = new Sprite3D();			triangleContainer.addChild(face);			var col:uint = Math.random()*12;						// SELECT RANDOM COLOR			if(col==0)				face.graphics3D.beginFill(0x1380EC, 1);//blue			else if(col==1)				face.graphics3D.beginFill(0xFFFFFF, 1);//white			else if(col==2)				face.graphics3D.beginFill(0x595959, 1);			else if(col==3)				face.graphics3D.beginFill(0x62ABF2, 1);//light blue			else if(col==4 || col==5)				face.graphics3D.beginFill(0xBBBBBB, 1);			else if(col==6 || col==7)				face.graphics3D.beginFill(0x666666, 1);			else if(col==8 || col==9)				face.graphics3D.beginFill(0x666666, 1);			else if(col==10 || col==11)				face.graphics3D.beginFill(0x999999, 1);						// Create triangle shape			face.graphics3D.moveTo(0, 0);			face.graphics3D.lineTo(Math.random()*100+5, 0);			face.graphics3D.lineTo(Math.random()*100+5, Math.random()*100+5);			face.graphics3D.lineTo(0, 0);			while(!checkCoordinates(x, y, z)){				trace("TOUCHING:"+x+", "+y+", "+z);				x = Math.random()*double-half;				y = Math.random()*double-half;				z = Math.random()*double-half;			}			face.x = x; //x;			face.y = y;			face.z = z;											face.rotationX = 0; //rotationx;			if(rotationy % 90 == 0){				face.rotationY = rotationy+1;			}else{				face.rotationY = rotationy;//182=-178			}							face.rotationZ = rotationz; //rotationz;			face.singleSided = false;			//face.childrenSorted = true;			face.flatShaded = false;			__scene.addChild(triangleContainer);			triangleContainer.x=triangleContainer.y=0;			__trianglesDictionary[__triangles] = triangleContainer;			__triangles++;		}					function checkOverlap(event:Event){			var virtualRY:int = 0;			//degrees = radians * 180/Math.PI						var container:Sprite3D = event.target as Sprite3D;			var containerRY:int;			var containerRX:int;					if(container.x > 0){ //RIGHT			if(container.z < 0){//TOP.. (test1-90)*-1;				containerRY = (((Math.atan2(container.x, container.z)* 180/Math.PI)-90)*-1)+360;//bottom left 5, -5, 135				//trace("tr:"+containerRY+" from:"+container.x+", "+container.z);			}else{//BOTTOM.. nada				containerRY = (Math.atan2(container.x, container.z)* 180/Math.PI); //GOOD				//trace("br:"+containerRY+" from:"+container.x+", "+container.z);			}					}else{//LEFT			if(container.z < 0){//TOP.. (x-90)*-1				containerRY = ((Math.atan2(container.x, container.z)*180/Math.PI)-90)*-1; // bottom left -5, 5, 135				//trace("Tl:"+containerRY+" from:"+container.x+", "+container.z);			}else{//BOTTOM ((x-90)*-1)+180			containerRY = ( ((Math.atan2(container.x, container.z)*180/Math.PI)) *-1)+90;//top left				//trace("Bl:"+containerRY+" from:"+container.x+", "+container.z);			}		}		//z is x.  y is y		if(container.z > 0){ //RIGHT			if(container.y < 0){//TOP.. (test1-90)*-1;				containerRX = (((Math.atan2(container.z, container.y)* 180/Math.PI)-90)*-1)+360;//bottom left 5, -5, 135				//trace("tr:"+containerRY+" from:"+container.z+", "+container.y);			}else{//BOTTOM.. nada				containerRX = (Math.atan2(container.z, container.y)* 180/Math.PI); //GOOD				//trace("br:"+containerRY+" from:"+container.z+", "+container.y);			}					}else{//LEFT			if(container.y < 0){//TOP.. (x-90)*-1				containerRX = ((Math.atan2(container.z, container.y)*180/Math.PI)-90)*-1; // bottom left -5, 5, 135				//trace("Tl:"+containerRY+" from:"+container.z+", "+container.y);			}else{//BOTTOM ((x-90)*-1)+180				containerRX = ( ((Math.atan2(container.z, container.y)*180/Math.PI)) *-1)+90;//top left				//trace("Bl:"+containerRY+" from:"+container.z+", "+container.y);			}		}					//if cX == 180  we need tX -90			// or if cx+tx == 90			//if cX == 270  we need tX -180			//trace("PP:"+containerRX+", "+containerRY+"..."+Trx.position+", "+Try.position);			//needs to be 270			if(containerRX + Trx.position < 180){ //if y's normal, we're good				if(containerRY + Try.position <= 225 && containerRY + Try.position > 135){					container.alpha = 0;				}else{					container.alpha = 1;				}			}else{				if(containerRY + Try.position <= 45 || containerRY + Try.position > 315){					container.alpha = 0;				}else{					container.alpha = 1;				}			}		}		function rollFace(e:Event){			trace("E: "+e.target.x+", "+e.target.y+", "+e.target.z+", "+e.target.rotationY);		}				function clickFace(event:MouseEvent){			Pause(true);			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			///OK.. if 2 sprites z=0 and 100.  if I do this.. it it rotates, the z now needs to be the x if it's rotated 90degrees Y			///change back all rY to random.. when i figure this out!			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////						var newX:int;			//sign(y) = opp/hyp			//trace("GGGGG:"+__trianglesDictionary[1].getChildAt(0));												  			if((event.target.rotationY / 90) > 2){ // find opposite  THIS ISN'T WORKING!...because it only does -180-180			//signy *hyp = opp				newX = -(event.target.z * Math.sin(event.target.rotationY));				trace("OPPOSITE");			}else{ // find adj			//cos =  adj/hyp				newX = -(event.target.z * Math.cos(event.target.rotationY));			}			//mc._x = a*Math.cos(r)*Math.cos(t) - b*Math.sin(r)*Math.sin(t);    	 	    //mc._y = a*Math.sin(r)*Math.cos(t) + b*Math.cos(r)*Math.sin(t);  			var newY:int = Math.sin(event.target.rotationX) * event.target.y;			trace("X:"+newX);			//newY = -(event.target.z * Math.sin(event.target.rotationY));			var newZ = event.target.x * Math.cos(event.target.rotationY);			//trace("z:"+event.target.z+", newX:"+newX)							__CHILDS=true;				Tx.continueTo(newX, 15);				Ty.continueTo(-newY, 15);				//Tz.continueTo(////newZ, 15);				Try.continueTo(-event.target.rotationY, 15);				Trx.continueTo(event.target.rotationX, 15);			trace("RY:"+event.target.rotationY);			trace(event.target.x+", "+event.target.y+", "+event.target.z);					}		var __CHILDS:Boolean;				private function checkCoordinates(theX:int, theY:int, theZ:int){			if(theX < 250 && theX > -250){				if(theY < 150 && theY > -150){					if(theZ < 150 && theZ > -150){						return false;					}else{						return true;					}				}else{					return true;				}			}else{				return true;			}					}		public function Pause(p:Boolean){			if(p){				Tz.removeEventListener(TweenEvent.MOTION_FINISH, TzContinueRandom);				Try.removeEventListener(TweenEvent.MOTION_FINISH, TryContinueRandom);				Trx.removeEventListener(TweenEvent.MOTION_FINISH, TrxContinueRandom);				Tz.stop();				Try.stop();				Trx.stop();						}else{				TzContinueRandom('');				TryContinueRandom('');				TrxContinueRandom('');				Tz.addEventListener(TweenEvent.MOTION_FINISH, TzContinueRandom);				Try.addEventListener(TweenEvent.MOTION_FINISH, TryContinueRandom);				Trx.addEventListener(TweenEvent.MOTION_FINISH, TrxContinueRandom);				//initializeMovement();			}		}//end Pause						/////////////////////////////////////////////////////////////////////////		/////////////////////////// TWEENS //////////////////////////////////////		/////////////////////////////////////////////////////////////////////////				public function initializeMovement(){			Ta = new Tween(this, "", Regular.easeInOut, 0, 1, 11, false);			Ta.addEventListener(TweenEvent.MOTION_CHANGE, applyA);						Tz = new Tween(this, "", Regular.easeInOut, 1000, 0, 20, false);			Tz.addEventListener(TweenEvent.MOTION_CHANGE, applyZ);						Tx = new Tween(this, "", Regular.easeInOut, stage.stageWidth, 50, 20, false);			Tx.addEventListener(TweenEvent.MOTION_CHANGE, applyX);						Ty = new Tween(this, "", Regular.easeInOut, world.y, world.y, 1, false);			Ty.addEventListener(TweenEvent.MOTION_CHANGE, applyY);						Try = new Tween(this, "", Regular.easeInOut, 0, 360, 45, false);			Try.addEventListener(TweenEvent.MOTION_CHANGE, applyRy);						//when finished with cool intro... redo this			Try.addEventListener(TweenEvent.MOTION_FINISH, initializeRandomness);			//do i need this?			//Ty = new Tween(__container, "y", Regular.easeInOut, 0, 0, 0, false);			Trx = new Tween(this, "", Regular.easeInOut, 0, 0, 0, false);			Try.addEventListener(TweenEvent.MOTION_CHANGE, applyRx);		}				private function applyA(event:Event){			__container.alpha = Ta.position;			for(var i:uint = 0; i<__triangles; i++){				__trianglesDictionary[i].alpha=Ta.position;			}		}				private function applyZ(event:Event){			__container.z = Tz.position;			for(var i:uint = 0; i< __triangles; i++){				__trianglesDictionary[i].z=Tz.position;			}		}				private function applyX(event:Event){			__container.x = Tx.position;			for(var i:uint = 0; i< __triangles; i++){				__trianglesDictionary[i].x=Tx.position;			}		}				private function applyY(event:Event){			__container.y = Ty.position;			for(var i:uint = 0; i< __triangles; i++){				__trianglesDictionary[i].y=Ty.position;			}		}				private function applyRy(event:Event){			__container.rotationY = Try.position;			for(var i:uint = 0; i< __triangles; i++){				__trianglesDictionary[i].rotationY=Try.position;			}		}		private function applyRx(event:Event){			__container.rotationX = Trx.position;			for(var i:uint = 0; i< __triangles; i++){				__trianglesDictionary[i].rotationX=Trx.position;			}		}				private function initializeRandomness(e){			trace("initializerandom");			Try.removeEventListener(TweenEvent.MOTION_FINISH, initializeRandomness);						TzContinueRandom('');			Tz.addEventListener(TweenEvent.MOTION_FINISH, TzContinueRandom);			TryContinueRandom('');			Try.addEventListener(TweenEvent.MOTION_FINISH, TryContinueRandom);			TrxContinueRandom('');			Trx.addEventListener(TweenEvent.MOTION_FINISH, TrxContinueRandom);		}		private function TzContinueRandom(e){			var randomTime:int = Math.random()*130+20;			var randomPosition:int = Math.random()*550-150;			Tz.continueTo(randomPosition, randomTime);			//trace("tz: "+randomPosition);		}		private function TryContinueRandom(e){			var randomTime:int = Math.random()*230+60;			var randomPosition = Math.random()*360-60;			//var randomPosition = Try.position+360;			while(!randomRotation(randomPosition)){				  randomPosition = Math.random()*360-60;			}			Try.continueTo(randomPosition, randomTime);		}		private function TrxContinueRandom(e){			var randomTime:int = Math.random()*230+60;			var randomPosition = Math.random()*360-60;			while(!randomRotation(randomPosition)){				  randomPosition = Math.random()*360-60;			}			Trx.continueTo(randomPosition, randomTime);//randomPosition			//trace("trXXXX:"+randomPosition);		}				private function randomRotation(i:int):Boolean{			if(i >= -60 && i <= 60)				return true;			else if(i >= 120 && i <= 240)				return true;			else if(i >= 300 && i <= 420)				return true;			else				return false;		}	}//end class}//end package